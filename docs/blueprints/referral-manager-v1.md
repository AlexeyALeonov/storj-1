# Referral Manager V1: Cross-Satellite Referral Link

## Abstract

This document describes how to handle user referrals across satellites.

## Background

The previous referral program only works per satellite. This means a user on us-east-1 satellite can only refer people to join us-east-1.

We want referrals to be valid on all Tardigrade satellites. This new design will allow the user to select any satellite, regardless of the satellite the referral was generated for.

### Non-Goals
A registration page where a user can select their preferred Satellite during registration.

## Design

### Definitions

Referral Manager
: A standalone process running separately from satellites. Only Tardigrade-branded satellites should be able to talk to it.

Referral Manager CLI
: A CLI that will allow operators to invoke referral link generation.

Invitation Token
: A random number generated by Referral Manager for each user in the referral program.

Referral Link
: A one-time-use URL that contains a unique invitation token.

Eligible Users
: Users who have 0 unredeemed referral links.

Owner's Satellite
: The satellite that the owner of a particular token belongs to.

Redeemed Satellite
: The satellite where the new user redeeming a token has registered on.

### How it will work

_User Interface_

1. Users will have a referral tab on the UI. When clicked, it will trigger the satellite to send a request to retrieve referral links from the Referral Manager:
    - The Referral Manager will query unredeemed tokens in the `tokens` table for this user ID and satellite.
        - If there are unredeemed tokens, the Referral Manager will respond to the satellite's request with the tokens.
        - If no unredeemed tokens are found for this user ID and such user ID doesn't exist in the Referral Manager's `users` table, the Referral Manager will add an entry for this user ID and in the `users` table.
    - The satellite receives the response from Referral Manager.
        - If the response payload contains tokens, the satellite will display them in the UI.
        - If it's an empty response payload, the satellite will display a message `No available referral links. Try again later.`


_Referral Manager CLI_

1. `referral-manager start` initiates the invitation token generation process. This process begins by checking whether there are existing `eligibleUsers` in memory in Referral Manager.
    - If `eligibleUsers` is empty, the Referral Manager queries `users` table to get users with 0 remaining invites.
    - If `eligibleUsers` is not empty, it means one of two things:
        * Someone else is using the Referral Manager at the same time and has not generated/sent tokens yet.
        * The CLI was terminated between the get `eligibleUsers` step and the generate/send tokens step.
    
        Either one of the cases, We will return an error and display `Referral token generation already in progress or canceled early. Do you want to continue anyway?`. If they decide to continue, we call `ClearUsers` to set `eligibleUsers` to empty and the Referral Manager queries the `users` table to get users with 0 remaining invites. 
2. The Referral Manager returns the number of users for each satellite to the CLI.
3. The CLI receives the number of users and displays: `How many invitations do you want to generate for each user?`
4. After the operator enters the number of invites per user to generate, the CLI displays: `Generating X invitation tokens for Y users on Z satellites. Yes/No.`
   - If the input is `Yes`, it will generate the amount of invitation tokens per user based on the input from CLI and save them into `tokens` table.
   - The CLI will call `ClearUsers` endpoint to set `eligibleUser` to be empty if the input is `No`.

_Referral Link Redemption_

1. User Alice tries to register a new account through a referral link, which triggers the redeemed satellite to verify invitation token using Referral manager.
2. Referral Manager checks the status of the token:
    - if the token exists in `tokens` table:
        - if it is not redeemed, Referral Manager sends back a success response to the redeemed satellite and mark the token as redeemed in the Referral Manager's database
        - if it token is already redeemed, Referral Manager sends back a `invalid token` response to the redeemed satellite.
        
    - if the token doesn't exist in `tokens` table, Referral Manager sends back a `invalid token` response to the redeemed satellite.
3. Redeemed satellite receives the response, which:
    - if it is a success, the satellite will proceed with the account creation and
    then send a request to the Referral Manager, which: 
        - updates the `tokens` table to store the newly created user ID in `redeemedID` column for that particular referral token.
        - updates the `users` table to store the newly created user ID and the satellite URL the user belongs to.
    - if it is an invalid token, the satellite will display a proper message in the UI.
    
## Rationale

We will create a `inspector` port that's only listening on `localhost` so CLI could be only used by Referral Manager operators.

We could also set the `inspector` port to only accept requests coming from storj vpn.

## Implementation

- Create a private repository for Referral Manager.
- Create `tokens` and `users` table in Referral Manager database.
- Create an `inspector` endpoint on Referral Manager.
    - Implementing a method `GenerateTokens` for generating referral tokens and save them into `tokens` table on Referral Manager.
    - Implementing a mathod `GetEligibleUsers` for querying users who don't have any referral tokens associated with.
- Implementing an endpoint `GetTokens` for requesting unredeemed tokens from Referral Manager. 
- Implementing an endpoint `Redeem` on Referral Manager for verifying invitation tokens and storing newly created user ID into `users` table.
- Implementing an endpoint `ClearUsers` on Referral Manager for setting in-memory `eligibleUsers` to be empty from Referral Manager CLI.
- Replace existing registration token logic.

### Pseudocode

The Token struct represents both a Go struct (on satellite and Referral Manager) as well as the schema for the `tokens` table on the Referral Manager

```
type Token struct {
    Secret [32]byte
    OwnerID uuid.UUID
    RedeemedID uuid.UUID
    OwnerSatelliteURL string
    RedeemedSatelliteURL string
    Status string
}
```
Statuses: `unsent` (owner's satellite doesn't know about it yet), `unredeemed` (owner's satellite knows about it but it has not been used), `redeemed` (someone has used this referral link to register alreadys)

The User struct represent both a Go struct as well as the schema for the `users` table on Referral Manager.

```
type User struct {
    ID uuid.UUID
    satelliteURL string
}
```


**Endpoints for satellites:**

```
// GetTokens retrieves a list of unredeemed tokens for a user.
GetTokens(userID uuid.UUID, satelliteURL string) []tokens {
    tokens := db.GetTokensByUserIDAndSatelliteURL(userID, satelliteURL)
    if len(tokens) < 1 {
        db.CreateUser(userID, satelliteURL)
    }

    return tokens
}

// Redeem marks a token as redeemed and stores user info into database
func Redeem(ctx, token, userID, satelliteURL) error {
	// only update the status if the status of a token is unredeems
	tokenStatus, err := db.UpdateToken(ctx, token, "redeemed")
	if err != nil {
		return err
	}

    // save user info into users table
    err := db.CreateUser(ctx, userID, satelliteURL)
    if err != nil {
        // log the error, but we shouldn't return an error to stop user registration process if we don't get their info here
        log(err)
        return
    }
}
```

**Endpoints for CLI:**

```
// GetEligibleUsers retrieves a list of users who have 0 remaining invitation tokens
// and saves those users in memory
GetEligibleUsers() ([]User, error) {
    if referralManager.eligibleUser != nil {
        return nil, UsersAlreadyRetrievedErr
    }

    users := db.GetUsers()
    referralManager.eligibleUsers = eligibleUsers

    return eligibleUsersCounts, nil
}

// GenerateTokens generates tokens, saves those in the referral manager db
GenerateTokens(tokensPerUser int) (int, error) {
    eligibleUsers := referralManager.eligibleUsers
    if eligibleUsers == nil {
        return nil, Error.New("No users to generate tokens for. Make sure to run GetEligibleUsers first")
    }
    var tokens []Token
    for _, users := range eligibleUsers {
        for i:=0; i<tokensPerUser; i++ {
            newToken := Token{data: generateRandomToken(), user: user.ID, satellite: user.satelliteURL}
            db.CreateToken(newToken)
            tokens = append(tokens, newToken)
        }
    }

    return len(tokens), nil
}

// ClearUsers sets eligibleUsers to be empty
func ClearUsers(ctx) {
    referralManager.eligibleUsers = nil
    return nil
}
```

**CLI code:**
```
startCmd() {
    eligibleUsers, err := referralManager.GetEligibleUsers()
    if err == UsersAlreadyRetrievedErr {
        confirm := prompt("Referral token generation already in progress or canceled early. Do you want to continue anyway?")
        if confirm != "y" {
            exit
        }
        referralManager.ClearUsers()
    } else if err != nil {
        exit
    }

    fmt.Printf("Total available user counts: %d\n", len(eligibleUsers))

    tokensPerUser := prompt("How many tokens do you want to generate per user?\n")
    totalTokens := tokensPerUser * total
    confirm := prompt("Are you sure you want to generate %d total tokens?\n", totalTokens)

    if confirm != "y" {
        referralManager.ClearUsers()
        exit
    }

    newTokens := referralManager.GenerateTokens(tokensPerUser)

    fmt.Printf("Successfully created %d tokens.\n", len(newTokens))
}
```

## Wrapup

Team Green will be responsible implementing this blueprint.

## Open issues